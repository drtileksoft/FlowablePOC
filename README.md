# Flowable Proof of Concept

This repository contains a complete playground for Flowable external workers. The Docker
Compose stack starts the Flowable REST engine alongside sample .NET workers that
showcase the integration patterns described in the `src` projects.

## Repository structure

| Path | Description |
| --- | --- |
| `src/AMCSSZ.NWF.Shared.ExternalFlowableWorker` | Reusable library that wraps the Flowable external job REST API and orchestrates polling, retries and error handling for custom handlers. |
| `src/AMCSSZ.NWF.Shared.ExternalFlowableWorkerImplementations` | Collection of ready-made worker implementations (HTTP handlers, helper utilities and DI extensions). |
| `src/AMCSSZ.NWF.Shared.FlowableHttpWorkerUsageExample` | Console worker host that references the implementations package and demonstrates how to register HTTP-based handlers. |
| `src/AMCSSZ.NWF.Shared.HttpLogApi` | Minimal ASP.NET Core API used as a target endpoint when testing the HTTP workers. |
| `srd-process.bpmn20.xml` | Sample process model that triggers the external task topic consumed by the workers. |

Each project has its own README with additional details and configuration examples.

## Running the stack locally

Build the containers and run them in the background:

```bash
docker compose up -d --build
```

Follow the worker logs while developing:

```bash
docker compose logs -f flowable-http-worker-usage-example
```

Useful lifecycle commands:

```bash
# stop/start/restart only the worker container
docker compose stop flowable-http-worker-usage-example
docker compose start flowable-http-worker-usage-example
docker compose restart flowable-http-worker-usage-example

# stop the entire stack
docker compose down

# drop the persisted PostgreSQL volume (removes data!)
docker volume rm flowableworker_dbdata

# stop everything and remove volumes in one step
docker compose down -v
```

## Flowable REST engine diagnostics

Tail the Flowable REST container logs:

```bash
docker compose logs -f flowable-rest
```

Check the engine version exposed by the remote sandbox:

```bash
curl -X GET --header 'Accept: application/json' 'https://flowable-pokusy-rest.evidencz.dev/flowable-rest/service/management/engine'
```

Open the autogenerated REST Swagger documentation:

```
http://localhost:8090/flowable-rest/docs/?url=specfile/external-worker/flowable-swagger-external-worker.json#/Acquire_and_Execute
```

## Deploying and testing the sample process

Deploy the BPMN model bundled in this repository:

```bash
curl -u rest-admin:test -X POST http://localhost:8090/flowable-rest/service/repository/deployments -H "Content-Type: multipart/form-data" -F "file=@srd-process.bpmn20.xml"
```

Verify the deployment and list the definitions:

```bash
curl -u rest-admin:test http://localhost:8090/flowable-rest/service/repository/process-definitions?key=srdProcess
curl -u rest-admin:test http://localhost:8090/flowable-rest/service/repository/process-definitions
```

Trigger manual acquisition of external jobs to see what the worker would receive:

```bash
curl -u rest-admin:test -X POST \
  http://localhost:8090/flowable-rest/external-job-api/acquire/jobs \
  -H "Content-Type: application/json" \
  -d '{"workerId":"test","maxJobs":5,"lockDuration":"PT30S","topic":"srd.call","fetchVariables":true}'
```

List finished instances of the sample process:

```bash
curl -u rest-admin:test "http://localhost:8090/flowable-rest/service/runtime/process-instances?processDefinitionKey=srdProcess&finished=true"
```

Inspect the HTTP log API that acts as the downstream service:

```bash
curl -X GET "https://httplogapi.azurewebsites.net/api/events/FLOWABLE_POC_WORKER?from=2025-10-13T22:00:00Z&to=2025-10-14T21:59:59Z"
```

## Modeling tips

Flowable waits for each external service task to be completed via the `/acquire/jobs/{id}/complete`
endpoint before moving to the next node. You can therefore model consecutive external tasks in BPMN
and the engine will only acquire the second one after the worker confirms the first task finished.

```xml
<serviceTask id="externalTask" name="External SRD Task"
             flowable:type="external"
             flowable:topic="srd.call"
             flowable:async="true" />
<serviceTask id="externalTask2" name="External SRD Task 2"
             flowable:type="external"
             flowable:topic="srd.call"
             flowable:async="true" />
```

For long-running or asynchronous downstream work, use a gateway that loops until the worker publishes
a completion flag via process variables:

```xml
<serviceTask id="externalTask" ... />
<exclusiveGateway id="waitForWorker" />
<sequenceFlow sourceRef="waitForWorker" targetRef="externalTask" >
  <conditionExpression xsi:type="tFormalExpression">
    <![CDATA[${srdStatus != 'OK'}]]>
  </conditionExpression>
</sequenceFlow>
<sequenceFlow sourceRef="waitForWorker" targetRef="externalTask2" >
  <conditionExpression xsi:type="tFormalExpression">
    <![CDATA[${srdStatus == 'OK'}]]>
  </conditionExpression>
</sequenceFlow>
```

The worker sample in `src/AMCSSZ.NWF.Shared.FlowableHttpWorkerUsageExample/Program.cs` already completes acquired jobs.
If a handler throws `FlowableJobRetryException`, the worker will call `acquire/jobs/{job.id}/fail`
and allow Flowable to retry the same task according to the configured back-off strategy.
